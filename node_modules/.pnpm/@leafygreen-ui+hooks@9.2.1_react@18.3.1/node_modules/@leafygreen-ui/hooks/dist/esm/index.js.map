{"version":3,"file":"index.js","sources":["../../src/useAutoScroll/useAutoScroll.ts","../../src/useSsrCheck.ts","../../src/useViewportSize.ts","../../src/useAvailableSpace/index.ts","../../src/useEventListener.ts","../../src/useBackdropClick.ts","../../src/useControlled/useControlled.ts","../../src/useControlledValue/useControlledValue.ts","../../src/useDynamicRefs/index.ts","../../src/useEscapeKey.ts","../../src/useFirstRender/useFirstRender.ts","../../src/useForceRerender/useForceRerender.tsx","../../src/useForwardedRef.tsx","../../src/useIdAllocator.ts","../../src/useIsomorphicLayoutEffect.ts","../../src/useMergeRefs/index.ts","../../src/useMobile/useMobile.ts","../../src/useMutationObserver.ts","../../src/useObjectDependency.ts","../../src/usePoller.ts","../../src/usePrevious.ts","../../src/useStateRef.ts","../../src/useValidation.tsx"],"sourcesContent":["import { RefObject, useEffect } from 'react';\n\n/**\n * Automatically scrolls the container to\n * ensure the elementRef is always at the top of the container.\n *\n * Required styles:\n * ```css\n * .container-parent {\n *    position: relative | absolute;\n * }\n *\n * .container {\n *    position: relative;\n *    max-height: {number};\n *    overflow: auto;\n * }\n *\n * .element {\n *    position: relative;\n *    height: {number}\n * }\n * ```\n */\nexport const useAutoScroll = (\n  /**\n   * The element to keep at the top\n   */\n  elementRef?: RefObject<HTMLElement>,\n  /**\n   * The container element\n   */\n  containerRef?: RefObject<HTMLElement>,\n  /**\n   * A vertical offset amount to account for padding/margin\n   */\n  offset = 0,\n) => {\n  // When the focused option changes, update the menu scroll if necessary\n  useEffect(() => {\n    if (\n      elementRef &&\n      elementRef.current &&\n      containerRef &&\n      containerRef.current\n    ) {\n      const { offsetTop: elementTop } = elementRef.current;\n      const { scrollTop: containerTop, offsetHeight: containerHeight } =\n        containerRef.current;\n\n      if (elementTop > containerHeight || elementTop < containerTop) {\n        containerRef.current.scrollTo({\n          top: elementTop - offset,\n          behavior: 'smooth', // TODO: update this based on prefers-reduced-motion\n        });\n      }\n    }\n  }, [containerRef, elementRef, offset]);\n};\n","import { useEffect, useState } from 'react';\n\nexport default function useSsrCheck() {\n  const [isSsr, setIsSsr] = useState(typeof window === 'undefined');\n\n  useEffect(() => {\n    // When rendered on server, this won't run until we're on the client. Therefore,\n    // isSsr should be true when server rendered, and only be set to false on subsequent client render.\n    // When rendered directly on the client, isSsr should already be false, so\n    // this update shouldn't trigger a re-render.\n    setIsSsr(false);\n  }, []);\n\n  return isSsr;\n}\n","import { useEffect, useState } from 'react';\nimport debounce from 'lodash/debounce';\n\nimport useSsrCheck from './useSsrCheck';\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n}\n\nfunction getViewportSize(): ViewportSize {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nexport default function useViewportSize(): ViewportSize | null {\n  const isSsr = useSsrCheck();\n\n  const [viewportSize, setViewportUpdateVal] = useState<ViewportSize | null>(\n    isSsr ? null : getViewportSize(), // window undefined on server\n  );\n\n  useEffect(() => {\n    const calcResize = debounce(\n      () => setViewportUpdateVal(getViewportSize()),\n      100,\n    );\n\n    // useEffect callback only runs on client, so safe to assume window is defined here\n    window.addEventListener('resize', calcResize);\n    return () => window.removeEventListener('resize', calcResize);\n  }, []);\n\n  return viewportSize;\n}\n","import useViewportSize from '../useViewportSize';\n\n/**\n * Returns the maximum space available above or below the source trigger\n * @param triggerRef The `ref` object attached to the source trigger\n * @param margin The space around the trigger\n */\nconst useAvailableSpace = (\n  triggerRef?: React.RefObject<HTMLElement>,\n  margin = 8,\n) => {\n  const viewportSize = useViewportSize();\n\n  if (viewportSize && triggerRef && triggerRef.current) {\n    // Get the top & bottom coordinates of the trigger\n    const { top: triggerTop, bottom: triggerBottom } =\n      triggerRef.current.getBoundingClientRect();\n\n    // Find out how much space is available above or below the trigger\n    const safeSpace = Math.max(viewportSize.height - triggerBottom, triggerTop);\n\n    // Return to fill the space available\n    return safeSpace - margin;\n  }\n};\n\nexport default useAvailableSpace;\n","import { useEffect, useRef } from 'react';\n\nexport interface UseEventOptions {\n  options?: Omit<AddEventListenerOptions, 'once'>;\n  dependencies?: Array<any>;\n  enabled?: boolean | 'once';\n  element?: Document | HTMLElement;\n}\n\n/**\n * Hook to subscribe to an event listener.\n * @param type Represents the event type to listen for.\n * @param eventCallback Event listener callback function.\n * @param optional Optional third argument passed to function with implementation specifications\n * @param optional.options Parameter to specify options passed to the eventListener.\n * @param optional.enabled Determines whether or not the useEffect hook should run.\n * @param optional.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param optional.element Value to be passed as target of event handler, will default to document.\n */\nexport default function useEventListener<Type extends keyof DocumentEventMap>(\n  type: Type,\n  eventCallback: (e: DocumentEventMap[Type]) => void,\n  {\n    options,\n    enabled = true,\n    dependencies = [enabled, type],\n    element,\n  }: UseEventOptions = {},\n) {\n  const memoizedEventCallback: React.MutableRefObject<\n    (e: DocumentEventMap[Type]) => void\n  > = useRef(() => {});\n\n  useEffect(() => {\n    memoizedEventCallback.current = eventCallback;\n  }, [eventCallback]);\n\n  useEffect(() => {\n    if (enabled === false) {\n      return;\n    }\n\n    // Handle this in case non-TypeScript users pass in the wrong value\n    if (enabled !== 'once' && enabled !== true) {\n      console.error(\n        `Received value of type ${typeof enabled} for property \\`enabled\\`. Expected a boolean.`,\n      );\n      return;\n    }\n\n    const callback = (e: DocumentEventMap[Type]) => {\n      memoizedEventCallback.current(e);\n    };\n\n    const eventListenerOptions = {\n      ...options,\n      once: enabled === 'once',\n    };\n\n    // NOTE(JeT): I'm pretty sure there should be a way to avoid this type assertion, but I couldn't figure it out.\n    (element ?? document).addEventListener(\n      type,\n      callback as EventListener,\n      eventListenerOptions,\n    );\n\n    return () => {\n      (element ?? document).removeEventListener(\n        type,\n        callback as EventListener,\n        eventListenerOptions,\n      );\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n","import { consoleOnce } from '@leafygreen-ui/lib';\n\nimport useEventListener from './useEventListener';\n\ninterface UseBackdropClickOptions {\n  /**\n   * Whether the callback is enabled.\n   * It's recommended to set this to `false` when not in use,\n   * and toggle to `true` when the main elements (menu, tooltip, etc) are visible\n   *\n   * @default true\n   */\n  enabled: boolean;\n\n  /**\n   * Allows the event to bubble up to other elements.\n   * When false, this ensures that only the `callback` is fired\n   * when the backdrop is clicked,\n   * (i.e. no other click event handlers are fired),\n   * and that the clicked element does not receive focus.\n   *\n   * To allow the event to propagate, set this to `true`,\n   * and ensure that you are correctly detecting whether the click target should receive focus,\n   * or whether focus should return to the popover trigger.\n   *\n   * @default false\n   */\n  allowPropagation?: boolean;\n}\n\n/**\n * Fires a callback when any element(s)\n * _except_ those passed in as `foreground` is clicked.\n *\n * Note: Disable this hook (with the `enabled` arg)\n * if the `foreground` element(s) are not in view (e.g. menu, tooltip, etc.).\n */\nexport function useBackdropClick(\n  /**\n   * Function called when any element\n   * _other than_ those provided is clicked.\n   *\n   * Callback is fired on the `click` event's capture phase,\n   * (i.e. before a click handler on the target element is fired)\n   */\n  callback: Function,\n\n  /**\n   * The primary element(s) that are excluded from backdrop click\n   */\n  foreground:\n    | React.RefObject<HTMLElement>\n    | Array<React.RefObject<HTMLElement>>,\n\n  /** Additional options for the hook. See {@link UseBackdropClickOptions} */\n  options: boolean | UseBackdropClickOptions = {\n    enabled: true,\n    allowPropagation: false,\n  },\n): void {\n  /**\n   * We add two event handlers to the document to handle the backdrop click behavior.\n   * Intended behavior is to fire the callback (usually closing a menu, tooltip, etc.),\n   * and keep focus on the component.\n   *\n   * No other click event handlers should fire on backdrop click\n   *\n   * 1. Mousedown event fires\n   * 2. We prevent `mousedown`'s default behavior, to prevent focus from being applied to the body (or other target)\n   * 3. Click event fires\n   * 4. We handle this event on _capture_, and stop propagation before the `click` event propagates all the way to any other element.\n   *  This ensures that even if we click on a button, that handler is not fired\n   * 5. Then we call the callback (typically fires `closeMenu`, setting `isOpen = false`, and rerender the component)\n   */\n\n  // TODO: Remove this in a major version\n  // https://jira.mongodb.org/browse/LG-5012\n  // To avoid a breaking change, we allow the `options` argument to be a boolean\n  // If it is a boolean, we assume that it is the `enabled` option\n  const { enabled, allowPropagation } =\n    typeof options === 'boolean'\n      ? { enabled: options, allowPropagation: false }\n      : options;\n\n  if (typeof options === 'boolean') {\n    consoleOnce.warn(\n      \"useBackdropClick: The 'enabled' boolean argument is deprecated. Please use the 'options' object argument instead.\",\n    );\n  }\n\n  useEventListener(\n    'mousedown',\n    mousedown => {\n      if (!doesComponentContainEventTarget(mousedown)) {\n        if (!allowPropagation) {\n          mousedown.preventDefault(); // Prevent focus from being applied to body\n          mousedown.stopPropagation(); // Stop any other mousedown events from firing\n        }\n      }\n    },\n    {\n      enabled,\n    },\n  );\n\n  useEventListener(\n    'click',\n    click => {\n      if (!doesComponentContainEventTarget(click)) {\n        if (!allowPropagation) {\n          click.stopPropagation(); // Stop any other click events from firing\n        }\n        callback(click);\n      }\n    },\n    {\n      options: { capture: true },\n      enabled,\n    },\n  );\n\n  /**\n   * Returns whether the event target within the component\n   */\n  function doesComponentContainEventTarget({ target }: MouseEvent): boolean {\n    return Array.isArray(foreground)\n      ? foreground.some(ref => ref.current?.contains(target as Node))\n      : foreground.current?.contains(target as Node) || false;\n  }\n}\n","import { useEffect, useMemo, useState } from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nimport { consoleOnce } from '@leafygreen-ui/lib';\n\nimport { ControlledReturnObject } from './useControlled.types';\n\n/**\n * A hook that enables a component to be both controlled or uncontrolled.\n *\n * Returns a {@link ControlledReturnObject}\n */\nexport const useControlled = <T extends any = undefined>(\n  controlledValue?: T,\n  onChange?: (val: T) => void,\n  initialValue?: T,\n): ControlledReturnObject<T> => {\n  /**\n   * isControlled should only be computed once\n   */\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const isControlled = useMemo(() => !isUndefined(controlledValue), []);\n\n  /**\n   * Keep track of the uncontrolled value state internally\n   *\n   * Note on type assertion:\n   * if `controlledValue` is undefined _and_ `initialValue` is also undefined,\n   * then T is necessarily `undefined`, so asserting `(initialValue as T)` is safe\n   */\n  const [uncontrolledValue, setUncontrolledValue] = useState<T>(\n    !isUndefined(controlledValue) ? controlledValue : (initialValue as T),\n  );\n\n  /**\n   * The returned value.\n   * If the component is uncontrolled, it will return the internal value.\n   * If the component is controlled, it will return the controlled value.\n   */\n  const value = useMemo(\n    () => (isControlled ? (controlledValue as T) : uncontrolledValue),\n    [isControlled, uncontrolledValue, controlledValue],\n  );\n\n  /**\n   * Updates the value of the component.\n   * If the component is uncontrolled, it will update the internal value.\n   * If the component is controlled, it will not update the controlled value.\n   *\n   * onChange callback is called if provided.\n   */\n  const updateValue = (newVal: T) => {\n    if (!isControlled) {\n      setUncontrolledValue(newVal);\n    }\n    onChange?.(newVal);\n  };\n\n  /**\n   * Log a warning if neither controlled value or initialValue is provided\n   */\n  useEffect(() => {\n    if (isUndefined(controlledValue) && isUndefined(initialValue)) {\n      consoleOnce.error(\n        `Warning: \\`useControlled\\` hook is being used without a value or initialValue. If using an input, this will cause a React warning when an input changes. Please decide between using a controlled or uncontrolled element, and provide either a controlledValue or initialValue to \\`useControlled\\``,\n      );\n    }\n  }, [controlledValue, initialValue]);\n\n  return {\n    isControlled,\n    value,\n    updateValue,\n    setUncontrolledValue,\n  };\n};\n","import { ChangeEventHandler, MutableRefObject } from 'react';\n\nimport { createSyntheticEvent } from '@leafygreen-ui/lib';\n\nimport { useControlled } from '../useControlled';\n\nimport { ControlledValueReturnObject } from './useControlledValue.types';\n\n/**\n * A hook that enables an input component to be both controlled or uncontrolled.\n *\n * Returns a {@link ControlledValueReturnObject} with the controlled or uncontrolled `value`,\n * `onChange` & `onClear` handlers, a `setInternalValue` setter, and a boolean `isControlled`\n */\nexport const useControlledValue = <T>(\n  controlledValue?: T,\n  changeHandler?: ChangeEventHandler<any> | null,\n  initialValue?: T,\n): ControlledValueReturnObject<T> => {\n  // Use the new useControlled hook under the hood\n  const { isControlled, value, setUncontrolledValue } = useControlled(\n    controlledValue,\n    undefined, // We'll handle onChange differently for input-specific logic\n    initialValue,\n  );\n\n  // Create a change event handler that either updates the internal state\n  // or fires an external change handler\n  const handleChange: ChangeEventHandler<any> = e => {\n    changeHandler?.(e);\n    if (!isControlled) {\n      setUncontrolledValue(e.target.value as T);\n    }\n  };\n\n  // A wrapper around `handleChange` that fires a simulated event\n  const updateValue = (newVal: T | undefined, ref: MutableRefObject<any>) => {\n    if (ref.current) {\n      ref.current.value = newVal;\n      const synthEvt = createSyntheticEvent(\n        new Event('change', {\n          cancelable: true,\n          bubbles: true,\n        }),\n        ref.current,\n      );\n\n      handleChange(synthEvt);\n    }\n  };\n\n  return {\n    isControlled,\n    value,\n    handleChange,\n    setUncontrolledValue,\n    updateValue,\n  };\n};\n","/**\n * Based on https://github.com/fitzmode/use-dynamic-refs/blob/master/src/index.tsx\n */\n\nimport * as React from 'react';\n\nimport { consoleOnce } from '@leafygreen-ui/lib';\n\nexport interface UseDynamicRefsArgs {\n  prefix?: string;\n}\n\n/** The Map type for a given ref object  */\nexport type RefMap<T> = Map<string, React.RefObject<T>>;\n\n/**\n * @internal\n */\nexport function getGetRef<T>(refMap: RefMap<T>) {\n  /**\n   * Returns a ref (or creates a new one) for the provided key\n   */\n  function getRef(): undefined;\n  function getRef(key: string): React.RefObject<T>;\n  function getRef(key?: string): React.RefObject<T> | undefined {\n    if (!key) {\n      consoleOnce.error('`useDynamicRefs`: Cannot get ref without key');\n      return;\n    }\n\n    if (refMap.get(key)) {\n      return refMap.get(key) as React.RefObject<T>;\n    }\n\n    const ref = React.createRef<T>();\n    refMap.set(key, ref);\n    return ref;\n  }\n\n  return getRef;\n}\n\n/** The function signature for the function returned by `useDynamicRefs` */\nexport type DynamicRefGetter<T> = ReturnType<typeof getGetRef<T>>;\n\n/**\n * Returns a ref \"getter\" function for the specified namespace (prefix).\n *\n * Calling the ref \"getter\" with a key will return a ref for the given namespace and key\n */\nexport function useDynamicRefs<T>(\n  args?: UseDynamicRefsArgs,\n): DynamicRefGetter<T> {\n  const prefix = args?.prefix;\n\n  const getRef = React.useMemo(\n    () => {\n      const refMap: RefMap<T> = new Map<string, React.RefObject<T>>();\n      const getter = getGetRef<T>(refMap);\n      return getter;\n    },\n    // FIXME:\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    prefix ? [prefix] : [],\n  );\n\n  return getRef;\n}\n","import useEventListener, { UseEventOptions } from './useEventListener';\n\nconst escapeKeyCode = 27;\n\nconst handleEscape = (e: KeyboardEvent, callback: () => void) => {\n  if (e.keyCode === escapeKeyCode) {\n    e.stopImmediatePropagation();\n    callback();\n  }\n};\n\n/**\n * Hook to subscribe to an escape-key-press.\n * @param callback Callback function to be executed when Escape key is pressed.\n * @param options Object to refine when callback is invoked.\n * @param options.options Parameter to specify options passed to the eventListener.\n * @param options.enabled Determines whether or not the useEffect hook should run.\n * @param options.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param options.element Value to be passed as target of event handler, will default to document.\n */\nconst useEscapeKey = (callback: () => void, options?: UseEventOptions) => {\n  return useEventListener('keydown', e => handleEscape(e, callback), options);\n};\n\nexport default useEscapeKey;\n","import { useEffect, useRef } from 'react';\n\n/**\n * Returns whether this is the first render of a component.\n *\n * Additionally, calls the provided callback function _only_ on first render\n */\nexport const useFirstRender = (effect?: () => void): boolean => {\n  const isFirstRender = useRef(true);\n\n  useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      effect?.();\n    }\n  }, [effect]);\n\n  return isFirstRender.current;\n};\n","import { useCallback, useState } from 'react';\n\n/**\n * Hook that forces a re-render.\n */\nexport function useForceRerender(): () => void {\n  const [, updateState] = useState<Object>({});\n  const forceRerender = useCallback(() => updateState({}), []);\n\n  return forceRerender;\n}\n","import { useCallback, useMemo, useRef } from 'react';\n\n// Ported from Select/utils\n// TODO: - remove duplicated code from Select/utils\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  initialValue: T,\n  options: { initialValue: T; deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  options?: { initialValue: T | null; deps?: React.DependencyList },\n): React.RefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | undefined) => void,\n  options?: { deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | null | undefined) => void,\n  {\n    initialValue,\n    deps = [],\n  }: { initialValue?: T | null; deps?: React.DependencyList } = {},\n) {\n  const ref = useRef(initialValue);\n\n  return useMemo(\n    () => ({\n      get current() {\n        return ref.current;\n      },\n      set current(nextValue) {\n        ref.current = nextValue;\n        callback(nextValue);\n      },\n    }),\n    [\n      callback,\n      ref,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      ...deps,\n    ],\n  );\n}\n\ntype SettableRef<T> = React.RefCallback<T> | React.MutableRefObject<T>;\n\ntype ValueOrArray<T> = T | ReadonlyArray<T>;\n\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n  initialValue: T,\n): React.MutableRefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null> | null>,\n  initialValue: T | null,\n): React.RefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null | undefined> | null>,\n  initialValue?: T | null,\n): React.MutableRefObject<T | null | undefined> {\n  const forwardValueToRefs = useCallback(\n    <T,>(\n      forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n      nextValue: T,\n    ) => {\n      if (Array.isArray(forwardedRefOrRefs)) {\n        forwardedRefOrRefs.forEach(forwardValueToRefs);\n      } else if (typeof forwardedRefOrRefs === 'function') {\n        forwardedRefOrRefs(nextValue);\n      } else if (forwardedRefOrRefs) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/40527\n        forwardedRefOrRefs.current = nextValue;\n      }\n    },\n    [],\n  );\n\n  return useObservedRef(\n    useCallback(\n      value => forwardValueToRefs(forwardedRefOrRefs, value),\n      [forwardedRefOrRefs, forwardValueToRefs],\n    ),\n    { initialValue },\n  );\n}\n","// Currently using Material UI useId hook until we can upgrade to React 18's useId\n// https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/useId.ts\nimport { useEffect, useState } from 'react';\n\ninterface Params {\n  prefix?: string;\n  id?: string;\n}\n\nlet globalId = 0;\n\nfunction useGlobalId({ id: idOverride, prefix }: Params): string {\n  const [defaultId, setDefaultId] = useState<string | number | undefined>(\n    idOverride,\n  );\n\n  useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(globalId);\n    }\n  }, [defaultId, prefix]);\n\n  return idOverride ? idOverride : `${prefix ?? 'lg'}-${defaultId}`;\n}\n\nexport default function useId({ prefix, id: idOverride }: Params): string {\n  return useGlobalId({ id: idOverride, prefix });\n}\n","import { useEffect, useLayoutEffect } from 'react';\n\nconst useIsomorphicLayoutEffect: typeof useLayoutEffect = (...args) => {\n  const effectHook =\n    typeof window === 'undefined' ? useEffect : useLayoutEffect;\n  return effectHook(...args);\n};\n\nexport default useIsomorphicLayoutEffect;\n","import * as React from 'react';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n */\nexport function useMergeRefs<Instance>(\n  refs: Array<React.Ref<Instance> | undefined>,\n): React.RefCallback<Instance> | null {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          (ref as React.MutableRefObject<Instance | null>).current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n","import { breakpoints } from '@leafygreen-ui/tokens';\n\nimport useViewportSize from '../useViewportSize';\n\n/**\n * Returns whether the viewport is mobile-sized\n */\nexport const useMobile = () => {\n  const viewport = useViewportSize();\n\n  const isMobileSize = viewport?.width\n    ? viewport.width <= breakpoints.Tablet\n    : false;\n\n  return {\n    isMobileSize,\n  };\n};\n","import { useEffect, useState } from 'react';\n\ntype MutationHandler<Value> = (\n  mutations: Array<MutationRecord>,\n  observer: MutationObserver,\n) => Value;\n\n/**\n * Hook to subscribe to changes on the DOM.\n * @param target HTML element that is subscribed to DOM changes.\n * @param options Object with information about what DOM changes to subscribe to.\n * @param callback Callback function to execute inside of MutationObserver instance.\n * @param enabled Determines whether or not the hook should run, defaults to true.\n */\nexport default function useMutationObserver<Value>(\n  target: HTMLElement | null,\n  options: MutationObserverInit,\n  callback: MutationHandler<Value>,\n  enabled = true,\n): Value | undefined {\n  const [value, setValue] = useState<Value>();\n\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const observer = new MutationObserver((...args) => {\n      setValue(callback(...args));\n    });\n\n    if (target) {\n      observer.observe(target, options);\n    }\n\n    return () => observer.disconnect();\n  }, [target, options, callback, enabled]);\n\n  return value;\n}\n","import { useRef } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nexport default function useObjectDependency<T>(object: T): T {\n  const ref = useRef<T>();\n\n  // we need isEqual for deep object comparison\n  if (ref.current === undefined || !isEqual(ref.current, object)) {\n    ref.current = object;\n  }\n\n  return ref.current;\n}\n","import { useEffect, useRef, useState } from 'react';\n\nimport useEventListener from './useEventListener';\n\nfunction useVisibilityChange() {\n  const isVisibilityStateVisible = () => document.visibilityState === 'visible';\n\n  const [isVisible, setIsVisible] = useState(true);\n\n  useEffect(() => {\n    setIsVisible(isVisibilityStateVisible);\n  }, []);\n\n  useEventListener('visibilitychange', () => {\n    setIsVisible(isVisibilityStateVisible);\n  });\n\n  return isVisible;\n}\n\ntype OnPoll = () => void;\n\ninterface PollerOptions {\n  /**\n   * How frequently should we call the onPoll handler. Defaults to 30 seconds.\n   * @default 30000\n   */\n  interval?: number;\n\n  /**\n   * Should we immediately trigger the onPoll handler.\n   * @default true\n   */\n  immediate?: boolean;\n\n  /**\n   * Should we be polling.\n   * @default true\n   */\n  enabled?: boolean;\n}\n\nexport default function usePoller(\n  onPoll: OnPoll,\n  { interval = 30e3, immediate = true, enabled = true }: PollerOptions = {},\n) {\n  const savedCallback = useRef<OnPoll>();\n  const isVisible = useVisibilityChange();\n\n  const isPolling = isVisible && enabled;\n\n  useEffect(() => {\n    savedCallback.current = onPoll;\n  });\n\n  useEffect(() => {\n    if (!isPolling) {\n      return;\n    }\n\n    // Using this reflection to get return type of setTimeout so we don't have to\n    // use window.setTimeout, makes this more cross-environment compatible\n    // Sourced from: https://stackoverflow.com/a/51040768\n    let id: ReturnType<typeof setTimeout>;\n\n    function scheduleNextPoll() {\n      unscheduleNextPoll();\n      id = setTimeout(poll, interval);\n    }\n\n    function unscheduleNextPoll() {\n      clearTimeout(id);\n    }\n\n    function poll() {\n      Promise.resolve(savedCallback.current?.()).finally(scheduleNextPoll);\n    }\n\n    if (immediate) {\n      poll();\n    } else {\n      scheduleNextPoll();\n    }\n\n    return unscheduleNextPoll;\n  }, [interval, immediate, isPolling]);\n}\n","import { useEffect, useRef } from 'react';\n\n/**\n * Hook to store previous props\n * https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state\n */\nexport default function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import { useCallback, useRef, useState } from 'react';\n\n/**\n *\n * A combination of useState and useRef,\n * returns the current state, a `setState` and a `getState` function.\n *\n * Use the `getState` function inside an event listener callbacks\n * in order to avoid referencing a stale state\n *\n * @param initial\n * @returns [state, setState, getState]\n */\nexport function useStateRef<T extends any>(\n  initial: T,\n): [T, (x: T) => void, () => T] {\n  const [state, _setState] = useState<T>(initial);\n  const ref = useRef<T>(state);\n\n  const setState = useCallback(\n    (newVal: T): void => {\n      _setState(newVal);\n      ref.current = newVal;\n    },\n    [_setState],\n  );\n\n  const getState = useCallback((): T => {\n    return ref.current;\n  }, []);\n\n  return [state, setState, getState];\n}\n","import { useState } from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nexport default function useValidation<\n  T extends HTMLInputElement | HTMLTextAreaElement,\n>(handleValidation?: (value: string) => void) {\n  const [isDirty, setIsDirty] = useState(false);\n\n  if (isUndefined(handleValidation) || typeof handleValidation !== 'function') {\n    return {\n      onBlur: () => {},\n      onChange: () => {},\n    };\n  }\n\n  const onBlur = (e: React.FocusEvent<T>) => {\n    setIsDirty(true);\n    handleValidation?.(e.target.value);\n  };\n\n  const onChange = (e: React.ChangeEvent<T>) => {\n    if (isDirty) {\n      handleValidation?.(e.target.value);\n    }\n  };\n\n  return {\n    onBlur,\n    onChange,\n  };\n}\n"],"names":["useAutoScroll","elementRef","containerRef","offset","arguments","length","undefined","useEffect","current","elementTop","offsetTop","_containerRef$current","containerTop","scrollTop","offsetHeight","scrollTo","top","behavior","useSsrCheck","_useState2","_slicedToArray","useState","window","isSsr","setIsSsr","getViewportSize","width","innerWidth","height","innerHeight","useViewportSize","viewportSize","setViewportUpdateVal","calcResize","debounce","addEventListener","removeEventListener","useAvailableSpace$1","triggerRef","margin","_triggerRef$current$g","getBoundingClientRect","triggerTop","triggerBottom","bottom","Math","max","useEventListener","type","eventCallback","_ref","options","_ref$enabled","enabled","_ref$dependencies","dependencies","element","memoizedEventCallback","useRef","callback","e","eventListenerOptions","_objectSpread","once","document","console","error","concat","_typeof","useBackdropClick","foreground","allowPropagation","doesComponentContainEventTarget","_ref2","_foreground$current","target","Array","isArray","some","ref","_ref$current","contains","consoleOnce","warn","mousedown","preventDefault","stopPropagation","click","capture","useControlled","controlledValue","onChange","initialValue","isControlled","useMemo","isUndefined","uncontrolledValue","setUncontrolledValue","value","updateValue","newVal","useControlledValue","changeHandler","_useControlled","handleChange","synthEvt","createSyntheticEvent","Event","cancelable","bubbles","useDynamicRefs","args","prefix","React","getter","refMap","key","get","createRef","set","getGetRef","Map","useEscapeKey$1","keyCode","stopImmediatePropagation","handleEscape","useFirstRender","effect","isFirstRender","useForceRerender","updateState","useCallback","useObservedRef","_ref$deps","deps","nextValue","_toConsumableArray","useForwardedRef","forwardedRefOrRefs","forwardValueToRefs","forEach","globalId","useId","idOverride","id","defaultId","setDefaultId","useGlobalId","useIsomorphicLayoutEffect$1","useLayoutEffect","apply","useMergeRefs","refs","every","useMobile","viewport","isMobileSize","breakpoints","Tablet","useMutationObserver","setValue","observer","MutationObserver","observe","disconnect","useObjectDependency","object","isEqual","usePoller","onPoll","_ref$interval","interval","_ref$immediate","immediate","savedCallback","isPolling","isVisibilityStateVisible","visibilityState","isVisible","setIsVisible","useVisibilityChange","poll","scheduleNextPoll","unscheduleNextPoll","setTimeout","clearTimeout","_savedCallback$curren","Promise","resolve","call","finally","usePrevious","useStateRef","initial","state","_setState","useValidation","handleValidation","isDirty","setIsDirty","onBlur"],"mappings":"qWAwBU,IAACA,EAAgB,SAAuBC,EAAYC,GAC5D,IAAIC,EAASC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,EAEjFG,EAAU,WACR,GAAIN,GAAcA,EAAWO,SAAWN,GAAgBA,EAAaM,QAAS,CAC5E,IAAIC,EAAaR,EAAWO,QAAQE,UAChCC,EAAwBT,EAAaM,QACvCI,EAAeD,EAAsBE,WAEnCJ,EADgBE,EAAsBG,cACNL,EAAaG,IAC/CV,EAAaM,QAAQO,SAAS,CAC5BC,IAAKP,EAAaN,EAClBc,SAAU,UAGf,CACF,EAAE,CAACf,EAAcD,EAAYE,GAChC,+gFCvCe,SAASe,IACtB,IACEC,EAAaC,EADCC,EAA2B,oBAAXC,QACS,GACvCC,EAAQJ,EAAW,GACnBK,EAAWL,EAAW,GAQxB,OAPAZ,EAAU,WAKRiB,GAAS,EACV,EAAE,IACID,CACT,CCXA,SAASE,IACP,MAAO,CACLC,MAAOJ,OAAOK,WACdC,OAAQN,OAAOO,YAEnB,CACe,SAASC,IACtB,IAAIP,EAAQL,IAGVC,EAAaC,EAFCC,EAASE,EAAQ,KAAOE,KAEC,GACvCM,EAAeZ,EAAW,GAC1Ba,EAAuBb,EAAW,GAYpC,OAXAZ,EAAU,WACR,IAAI0B,EAAaC,EAAS,WACxB,OAAOF,EAAqBP,IAC7B,EAAE,KAIH,OADAH,OAAOa,iBAAiB,SAAUF,GAC3B,WACL,OAAOX,OAAOc,oBAAoB,SAAUH,EAClD,CACG,EAAE,IACIF,CACT,CCtBA,IAgBAM,EAhBwB,SAA2BC,GACjD,IAAIC,EAASnC,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,EAC7E2B,EAAeD,IACnB,GAAIC,GAAgBO,GAAcA,EAAW9B,QAAS,CAEpD,IAAIgC,EAAwBF,EAAW9B,QAAQiC,wBAC7CC,EAAaF,EAAsBxB,IACnC2B,EAAgBH,EAAsBI,OAMxC,OAHgBC,KAAKC,IAAIf,EAAaH,OAASe,EAAeD,GAG3CH,CACpB,CACH,ECVe,SAASQ,EAAiBC,EAAMC,GAC7C,IAAIC,EAAO9C,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAAE,EAC/E+C,EAAUD,EAAKC,QACfC,EAAeF,EAAKG,QACpBA,OAA2B,IAAjBD,GAAiCA,EAC3CE,EAAoBJ,EAAKK,aACzBA,OAAqC,IAAtBD,EAA+B,CAACD,EAASL,GAAQM,EAChEE,EAAUN,EAAKM,QACbC,EAAwBC,EAAO,WAAY,GAC/CnD,EAAU,WACRkD,EAAsBjD,QAAUyC,CACpC,EAAK,CAACA,IACJ1C,EAAU,WACR,IAAgB,IAAZ8C,EAAJ,CAKA,GAAgB,SAAZA,IAAkC,IAAZA,EAA1B,CAIA,IAAIM,EAAW,SAAkBC,GAC/BH,EAAsBjD,QAAQoD,EACpC,EACQC,EAAuBC,EAAcA,EAAc,CAAA,EAAIX,GAAU,GAAI,CACvEY,KAAkB,SAAZV,IAKR,OADCG,QAAyCA,EAAUQ,UAAU7B,iBAAiBa,EAAMW,EAAUE,GACxF,YACJL,QAAyCA,EAAUQ,UAAU5B,oBAAoBY,EAAMW,EAAUE,EACxG,CAZK,CAFCI,QAAQC,MAAM,0BAA0BC,OAAOC,EAAQf,GAAU,gDAJlE,CAoBF,EAAEE,EACL,CCvCO,SAASc,EAQhBV,EAIAW,GACE,IAAInB,EAAU/C,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAChFiD,SAAS,EACTkB,kBAAkB,GAqBhBrB,EAA0B,kBAAZC,EAAwB,CACtCE,QAASF,EACToB,kBAAkB,GAChBpB,EACJE,EAAUH,EAAKG,QACfkB,EAAmBrB,EAAKqB,iBA+B1B,SAASC,EAAgCC,GACvC,IAAIC,EACAC,EAASF,EAAME,OACnB,OAAOC,MAAMC,QAAQP,GAAcA,EAAWQ,KAAK,SAAUC,GAC3D,IAAIC,EACJ,OAAwC,QAAhCA,EAAeD,EAAIvE,eAAsC,IAAjBwE,OAA0B,EAASA,EAAaC,SAASN,EAC/G,IAAyD,QAA9CD,EAAsBJ,EAAW9D,eAA6C,IAAxBkE,OAAiC,EAASA,EAAoBO,SAASN,MAAY,CACjJ,CArCsB,kBAAZxB,GACT+B,EAAYC,KAAK,qHAEnBpC,EAAiB,YAAa,SAAUqC,GACjCZ,EAAgCY,IAC9Bb,IACHa,EAAUC,iBACVD,EAAUE,kBAGlB,EAAK,CACDjC,QAASA,IAEXN,EAAiB,QAAS,SAAUwC,GAC7Bf,EAAgCe,KAC9BhB,GACHgB,EAAMD,kBAER3B,EAAS4B,GAEf,EAAK,CACDpC,QAAS,CACPqC,SAAS,GAEXnC,QAASA,GAcb,CChFU,IAACoC,EAAgB,SAAuBC,EAAiBC,EAAUC,GAK3E,IAAIC,EAAeC,EAAQ,WACzB,OAAQC,EAAYL,EACrB,EAAE,IAUDvE,EAAaC,EADCC,EAAU0E,EAAYL,GAAqCE,EAAlBF,GAChB,GACvCM,EAAoB7E,EAAW,GAC/B8E,EAAuB9E,EAAW,GAOhC+E,EAAQJ,EAAQ,WAClB,OAAOD,EAAeH,EAAkBM,CACzC,EAAE,CAACH,EAAcG,EAAmBN,IAwBrC,OALAnF,EAAU,WACJwF,EAAYL,IAAoBK,EAAYH,IAC9CV,EAAYhB,MAAM,mSAExB,EAAK,CAACwB,EAAiBE,IACd,CACLC,aAAcA,EACdK,MAAOA,EACPC,YAlBgB,SAAqBC,GAChCP,GACHI,EAAqBG,GAEvBT,SAA4CA,EAASS,EACzD,EAcIH,qBAAsBA,EAE1B,EC3DWI,EAAqB,SAA4BX,EAAiBY,EAAeV,GAE1F,IAAIW,EAAiBd,EAAcC,OAAiBpF,EAElDsF,GACAC,EAAeU,EAAeV,aAC9BK,EAAQK,EAAeL,MACvBD,EAAuBM,EAAeN,qBAIpCO,EAAe,SAAsB5C,GACvC0C,SAAsDA,EAAc1C,GAC/DiC,GACHI,EAAqBrC,EAAEe,OAAOuB,MAEpC,EAaE,MAAO,CACLL,aAAcA,EACdK,MAAOA,EACPM,aAAcA,EACdP,qBAAsBA,EACtBE,YAfgB,SAAqBC,EAAQrB,GAC7C,GAAIA,EAAIvE,QAAS,CACfuE,EAAIvE,QAAQ0F,MAAQE,EACpB,IAAIK,EAAWC,EAAqB,IAAIC,MAAM,SAAU,CACtDC,YAAY,EACZC,SAAS,IACP9B,EAAIvE,SACRgG,EAAaC,EACd,CACL,EAQA,ECLO,SAASK,EAAeC,GAC7B,IAAIC,EAASD,aAAmC,EAASA,EAAKC,OAS9D,OARaC,EAAMnB,QAAQ,WACzB,IACIoB,EA/BD,SAAmBC,GAiBxB,OAZA,SAAgBC,GACd,GAAKA,EAAL,CAIA,GAAID,EAAOE,IAAID,GACb,OAAOD,EAAOE,IAAID,GAEpB,IAAIrC,EAAmBkC,EAAMK,YAE7B,OADAH,EAAOI,IAAIH,EAAKrC,GACTA,CANN,CAFCG,EAAYhB,MAAM,+CASrB,CAEH,CAaiBsD,CADA,IAAIC,KAEjB,OAAOP,CACR,EAGDF,EAAS,CAACA,GAAU,GAEtB,CCjDA,IAsBAU,EALmB,SAAsB/D,EAAUR,GACjD,OAAOJ,EAAiB,UAAW,SAAUa,GAC3C,OAlBe,SAAsBA,EAAGD,GADxB,KAEdC,EAAE+D,UACJ/D,EAAEgE,2BACFjE,IAEJ,CAaWkE,CAAajE,EAAGD,EACxB,EAAER,EACL,ECfW2E,EAAiB,SAAwBC,GAClD,IAAIC,EAAgBtE,GAAO,GAO3B,OANAnD,EAAU,WACJyH,EAAcxH,UAChBwH,EAAcxH,SAAU,EACxBuH,SAAwCA,IAE9C,EAAK,CAACA,IACGC,EAAcxH,OACvB,ECVO,SAASyH,IACd,IAEEC,EADa9G,EADCC,EAAS,IACgB,GACd,GAI3B,OAHoB8G,EAAY,WAC9B,OAAOD,EAAY,CAAA,EACpB,EAAE,GAEL,CCRO,SAASE,EAAezE,GAC7B,IAAIT,EAAO9C,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAAE,EAC/EwF,EAAe1C,EAAK0C,aACpByC,EAAYnF,EAAKoF,KACjBA,OAAqB,IAAdD,EAAuB,GAAKA,EACjCtD,EAAMrB,EAAOkC,GACjB,OAAOE,EAAQ,WACb,MAAO,CACL,WAAItF,GACF,OAAOuE,EAAIvE,OACZ,EACD,WAAIA,CAAQ+H,GACVxD,EAAIvE,QAAU+H,EACd5E,EAAS4E,EACV,EAEP,EAAK,CAAC5E,EAAUoB,GAAKZ,OAAOqE,EAAmBF,IAC/C,CACO,SAASG,EAAgBC,EAAoB9C,GAClD,IAAI+C,EAAqBR,EAAY,SAAUO,EAAoBH,GAC7D3D,MAAMC,QAAQ6D,GAChBA,EAAmBE,QAAQD,GACY,mBAAvBD,EAChBA,EAAmBH,GACVG,IAETA,EAAmBlI,QAAU+H,EAEhC,EAAE,IACH,OAAOH,EAAeD,EAAY,SAAUjC,GAC1C,OAAOyC,EAAmBD,EAAoBxC,EAClD,EAAK,CAACwC,EAAoBC,IAAsB,CAC5C/C,aAAcA,GAElB,CCpCA,IAAIiD,EAAW,EAoBA,SAASC,EAAMrE,GAC5B,IAAIuC,EAASvC,EAAMuC,OAEnB,OAtBF,SAAqB9D,GACnB,IAAI6F,EAAa7F,EAAK8F,GACpBhC,EAAS9D,EAAK8D,OAEd7F,EAAaC,EADCC,EAAS0H,GACgB,GACvCE,EAAY9H,EAAW,GACvB+H,EAAe/H,EAAW,GAW5B,OAVAZ,EAAU,WACS,MAAb0I,GAMFC,EADAL,GAAY,EAGlB,EAAK,CAACI,EAAWjC,IACR+B,GAA0B,GAAG5E,OAAO6C,QAAuCA,EAAS,KAAM,KAAK7C,OAAO8E,EAC/G,CAISE,CAAY,CACjBH,GAFavE,EAAMuE,GAGnBhC,OAAQA,GAEZ,CC9BA,IAIAoC,EAJgC,WAE9B,OADmC,oBAAX9H,OAAyBf,EAAY8I,GAC3CC,WAAM,EAAQlJ,UAClC,ECCO,SAASmJ,EAAaC,GAC3B,OAAOvC,EAAMnB,QAAQ,WACnB,OAAI0D,EAAKC,MAAM,SAAU1E,GACvB,OAAc,MAAPA,CACb,GACa,KAEF,SAAUmB,GACfsD,EAAKZ,QAAQ,SAAU7D,GACF,mBAARA,EACTA,EAAImB,GACY,MAAPnB,IACTA,EAAIvE,QAAU0F,EAExB,EACA,CAEG,EAAEsD,EACL,CCjBU,IAACE,EAAY,WACrB,IAAIC,EAAW7H,IAEf,MAAO,CACL8H,eAFiBD,UAA4CA,EAASjI,QAAQiI,EAASjI,OAASmI,EAAYC,OAIhH,ECHe,SAASC,EAAoBpF,EAAQxB,EAASQ,GAC3D,IAAIN,IAAUjD,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,KAAmBA,UAAU,GAE3Ee,EAAaC,EADCC,IACyB,GACvC6E,EAAQ/E,EAAW,GACnB6I,EAAW7I,EAAW,GAexB,OAdAZ,EAAU,WACR,GAAK8C,EAAL,CAGA,IAAI4G,EAAW,IAAIC,iBAAiB,WAClCF,EAASrG,EAAS2F,WAAM,EAAQlJ,WACtC,GAII,OAHIuE,GACFsF,EAASE,QAAQxF,EAAQxB,GAEpB,WACL,OAAO8G,EAASG,YACtB,CATK,CAUF,EAAE,CAACzF,EAAQxB,EAASQ,EAAUN,IACxB6C,CACT,CC5Be,SAASmE,EAAoBC,GAC1C,IAAIvF,EAAMrB,IAMV,YAHoBpD,IAAhByE,EAAIvE,SAA0B+J,EAAQxF,EAAIvE,QAAS8J,KACrDvF,EAAIvE,QAAU8J,GAETvF,EAAIvE,OACb,CCSe,SAASgK,EAAUC,GAChC,IAAIvH,EAAO9C,UAAUC,OAAS,QAAsBC,IAAjBF,UAAU,GAAmBA,UAAU,GAAK,CAAE,EAC/EsK,EAAgBxH,EAAKyH,SACrBA,OAA6B,IAAlBD,EAA2B,IAAOA,EAC7CE,EAAiB1H,EAAK2H,UACtBA,OAA+B,IAAnBD,GAAmCA,EAC/CxH,EAAeF,EAAKG,QACpBA,OAA2B,IAAjBD,GAAiCA,EACzC0H,EAAgBpH,IAEhBqH,EA1BN,WACE,IAAIC,EAA2B,WAC7B,MAAoC,YAA7BhH,SAASiH,eACpB,EAEI9J,EAAaC,EADCC,GAAS,GACgB,GACvC6J,EAAY/J,EAAW,GACvBgK,EAAehK,EAAW,GAO5B,OANAZ,EAAU,WACR4K,EAAaH,EACd,EAAE,IACHjI,EAAiB,mBAAoB,WACnCoI,EAAaH,EACjB,GACSE,CACT,CAUkBE,IACa/H,EAC7B9C,EAAU,WACRuK,EAActK,QAAUiK,CAC5B,GACElK,EAAU,WAQR,IAAIyI,EAPJ,GAAK+B,EAwBL,OALIF,EACFQ,IAEAC,IAEKC,EAhBP,SAASD,IACPC,IACAvC,EAAKwC,WAAWH,EAAMV,EACvB,CACD,SAASY,IACPE,aAAazC,EACd,CACD,SAASqC,IACP,IAAIK,EACJC,QAAQC,QAA4D,QAAnDF,EAAwBZ,EAActK,eAA+C,IAA1BkL,OAAmC,EAASA,EAAsBG,KAAKf,IAAgBgB,QAAQR,EAC5K,CAOF,EAAE,CAACX,EAAUE,EAAWE,GAC3B,CCtDe,SAASgB,EAAY7F,GAClC,IAAInB,EAAMrB,IAIV,OAHAnD,EAAU,WACRwE,EAAIvE,QAAU0F,CAClB,GACSnB,EAAIvE,OACb,CCEO,SAASwL,EAAYC,GAC1B,IACE9K,EAAaC,EADCC,EAAS4K,GACgB,GACvCC,EAAQ/K,EAAW,GACnBgL,EAAYhL,EAAW,GACrB4D,EAAMrB,EAAOwI,GAQjB,MAAO,CAACA,EAPO/D,EAAY,SAAU/B,GACnC+F,EAAU/F,GACVrB,EAAIvE,QAAU4F,CAClB,EAAK,CAAC+F,IACWhE,EAAY,WACzB,OAAOpD,EAAIvE,OACZ,EAAE,IAEL,CCzBe,SAAS4L,EAAcC,GACpC,IACElL,EAAaC,EADCC,GAAS,GACgB,GACvCiL,EAAUnL,EAAW,GACrBoL,EAAapL,EAAW,GAC1B,GAAI4E,EAAYsG,IAAiD,mBAArBA,EAC1C,MAAO,CACLG,OAAQ,WAAoB,EAC5B7G,SAAU,WAAsB,GAYpC,MAAO,CACL6G,OAVW,SAAgB5I,GAC3B2I,GAAW,GACXF,SAA4DA,EAAiBzI,EAAEe,OAAOuB,MAC1F,EAQIP,SAPa,SAAkB/B,GAC3B0I,IACFD,SAA4DA,EAAiBzI,EAAEe,OAAOuB,OAE5F,EAKA"}