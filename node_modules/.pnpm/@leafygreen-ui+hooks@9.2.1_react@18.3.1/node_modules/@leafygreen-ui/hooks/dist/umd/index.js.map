{"version":3,"file":"index.js","sources":["../../src/useSsrCheck.ts","../../src/useViewportSize.ts","../../src/useAvailableSpace/index.ts","../../src/useEventListener.ts","../../src/useControlled/useControlled.ts","../../src/useEscapeKey.ts","../../src/useForwardedRef.tsx","../../src/useIdAllocator.ts","../../src/useIsomorphicLayoutEffect.ts","../../src/useAutoScroll/useAutoScroll.ts","../../src/useBackdropClick.ts","../../src/useControlledValue/useControlledValue.ts","../../src/useDynamicRefs/index.ts","../../src/useFirstRender/useFirstRender.ts","../../src/useForceRerender/useForceRerender.tsx","../../src/useMergeRefs/index.ts","../../src/useMobile/useMobile.ts","../../src/useMutationObserver.ts","../../src/useObjectDependency.ts","../../src/usePoller.ts","../../src/usePrevious.ts","../../src/useStateRef.ts","../../src/useValidation.tsx"],"sourcesContent":["import { useEffect, useState } from 'react';\n\nexport default function useSsrCheck() {\n  const [isSsr, setIsSsr] = useState(typeof window === 'undefined');\n\n  useEffect(() => {\n    // When rendered on server, this won't run until we're on the client. Therefore,\n    // isSsr should be true when server rendered, and only be set to false on subsequent client render.\n    // When rendered directly on the client, isSsr should already be false, so\n    // this update shouldn't trigger a re-render.\n    setIsSsr(false);\n  }, []);\n\n  return isSsr;\n}\n","import { useEffect, useState } from 'react';\nimport debounce from 'lodash/debounce';\n\nimport useSsrCheck from './useSsrCheck';\n\ninterface ViewportSize {\n  width: number;\n  height: number;\n}\n\nfunction getViewportSize(): ViewportSize {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n}\n\nexport default function useViewportSize(): ViewportSize | null {\n  const isSsr = useSsrCheck();\n\n  const [viewportSize, setViewportUpdateVal] = useState<ViewportSize | null>(\n    isSsr ? null : getViewportSize(), // window undefined on server\n  );\n\n  useEffect(() => {\n    const calcResize = debounce(\n      () => setViewportUpdateVal(getViewportSize()),\n      100,\n    );\n\n    // useEffect callback only runs on client, so safe to assume window is defined here\n    window.addEventListener('resize', calcResize);\n    return () => window.removeEventListener('resize', calcResize);\n  }, []);\n\n  return viewportSize;\n}\n","import useViewportSize from '../useViewportSize';\n\n/**\n * Returns the maximum space available above or below the source trigger\n * @param triggerRef The `ref` object attached to the source trigger\n * @param margin The space around the trigger\n */\nconst useAvailableSpace = (\n  triggerRef?: React.RefObject<HTMLElement>,\n  margin = 8,\n) => {\n  const viewportSize = useViewportSize();\n\n  if (viewportSize && triggerRef && triggerRef.current) {\n    // Get the top & bottom coordinates of the trigger\n    const { top: triggerTop, bottom: triggerBottom } =\n      triggerRef.current.getBoundingClientRect();\n\n    // Find out how much space is available above or below the trigger\n    const safeSpace = Math.max(viewportSize.height - triggerBottom, triggerTop);\n\n    // Return to fill the space available\n    return safeSpace - margin;\n  }\n};\n\nexport default useAvailableSpace;\n","import { useEffect, useRef } from 'react';\n\nexport interface UseEventOptions {\n  options?: Omit<AddEventListenerOptions, 'once'>;\n  dependencies?: Array<any>;\n  enabled?: boolean | 'once';\n  element?: Document | HTMLElement;\n}\n\n/**\n * Hook to subscribe to an event listener.\n * @param type Represents the event type to listen for.\n * @param eventCallback Event listener callback function.\n * @param optional Optional third argument passed to function with implementation specifications\n * @param optional.options Parameter to specify options passed to the eventListener.\n * @param optional.enabled Determines whether or not the useEffect hook should run.\n * @param optional.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param optional.element Value to be passed as target of event handler, will default to document.\n */\nexport default function useEventListener<Type extends keyof DocumentEventMap>(\n  type: Type,\n  eventCallback: (e: DocumentEventMap[Type]) => void,\n  {\n    options,\n    enabled = true,\n    dependencies = [enabled, type],\n    element,\n  }: UseEventOptions = {},\n) {\n  const memoizedEventCallback: React.MutableRefObject<\n    (e: DocumentEventMap[Type]) => void\n  > = useRef(() => {});\n\n  useEffect(() => {\n    memoizedEventCallback.current = eventCallback;\n  }, [eventCallback]);\n\n  useEffect(() => {\n    if (enabled === false) {\n      return;\n    }\n\n    // Handle this in case non-TypeScript users pass in the wrong value\n    if (enabled !== 'once' && enabled !== true) {\n      console.error(\n        `Received value of type ${typeof enabled} for property \\`enabled\\`. Expected a boolean.`,\n      );\n      return;\n    }\n\n    const callback = (e: DocumentEventMap[Type]) => {\n      memoizedEventCallback.current(e);\n    };\n\n    const eventListenerOptions = {\n      ...options,\n      once: enabled === 'once',\n    };\n\n    // NOTE(JeT): I'm pretty sure there should be a way to avoid this type assertion, but I couldn't figure it out.\n    (element ?? document).addEventListener(\n      type,\n      callback as EventListener,\n      eventListenerOptions,\n    );\n\n    return () => {\n      (element ?? document).removeEventListener(\n        type,\n        callback as EventListener,\n        eventListenerOptions,\n      );\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n}\n","import { useEffect, useMemo, useState } from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nimport { consoleOnce } from '@leafygreen-ui/lib';\n\nimport { ControlledReturnObject } from './useControlled.types';\n\n/**\n * A hook that enables a component to be both controlled or uncontrolled.\n *\n * Returns a {@link ControlledReturnObject}\n */\nexport const useControlled = <T extends any = undefined>(\n  controlledValue?: T,\n  onChange?: (val: T) => void,\n  initialValue?: T,\n): ControlledReturnObject<T> => {\n  /**\n   * isControlled should only be computed once\n   */\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  const isControlled = useMemo(() => !isUndefined(controlledValue), []);\n\n  /**\n   * Keep track of the uncontrolled value state internally\n   *\n   * Note on type assertion:\n   * if `controlledValue` is undefined _and_ `initialValue` is also undefined,\n   * then T is necessarily `undefined`, so asserting `(initialValue as T)` is safe\n   */\n  const [uncontrolledValue, setUncontrolledValue] = useState<T>(\n    !isUndefined(controlledValue) ? controlledValue : (initialValue as T),\n  );\n\n  /**\n   * The returned value.\n   * If the component is uncontrolled, it will return the internal value.\n   * If the component is controlled, it will return the controlled value.\n   */\n  const value = useMemo(\n    () => (isControlled ? (controlledValue as T) : uncontrolledValue),\n    [isControlled, uncontrolledValue, controlledValue],\n  );\n\n  /**\n   * Updates the value of the component.\n   * If the component is uncontrolled, it will update the internal value.\n   * If the component is controlled, it will not update the controlled value.\n   *\n   * onChange callback is called if provided.\n   */\n  const updateValue = (newVal: T) => {\n    if (!isControlled) {\n      setUncontrolledValue(newVal);\n    }\n    onChange?.(newVal);\n  };\n\n  /**\n   * Log a warning if neither controlled value or initialValue is provided\n   */\n  useEffect(() => {\n    if (isUndefined(controlledValue) && isUndefined(initialValue)) {\n      consoleOnce.error(\n        `Warning: \\`useControlled\\` hook is being used without a value or initialValue. If using an input, this will cause a React warning when an input changes. Please decide between using a controlled or uncontrolled element, and provide either a controlledValue or initialValue to \\`useControlled\\``,\n      );\n    }\n  }, [controlledValue, initialValue]);\n\n  return {\n    isControlled,\n    value,\n    updateValue,\n    setUncontrolledValue,\n  };\n};\n","import useEventListener, { UseEventOptions } from './useEventListener';\n\nconst escapeKeyCode = 27;\n\nconst handleEscape = (e: KeyboardEvent, callback: () => void) => {\n  if (e.keyCode === escapeKeyCode) {\n    e.stopImmediatePropagation();\n    callback();\n  }\n};\n\n/**\n * Hook to subscribe to an escape-key-press.\n * @param callback Callback function to be executed when Escape key is pressed.\n * @param options Object to refine when callback is invoked.\n * @param options.options Parameter to specify options passed to the eventListener.\n * @param options.enabled Determines whether or not the useEffect hook should run.\n * @param options.dependencies Array to be passed to useEffect hook, such that the hook will only run if the array's values have changed.\n * @param options.element Value to be passed as target of event handler, will default to document.\n */\nconst useEscapeKey = (callback: () => void, options?: UseEventOptions) => {\n  return useEventListener('keydown', e => handleEscape(e, callback), options);\n};\n\nexport default useEscapeKey;\n","import { useCallback, useMemo, useRef } from 'react';\n\n// Ported from Select/utils\n// TODO: - remove duplicated code from Select/utils\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  initialValue: T,\n  options: { initialValue: T; deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T) => void,\n  options?: { initialValue: T | null; deps?: React.DependencyList },\n): React.RefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | undefined) => void,\n  options?: { deps?: React.DependencyList },\n): React.MutableRefObject<T>;\nexport function useObservedRef<T>(\n  callback: (value: T | null | undefined) => void,\n  {\n    initialValue,\n    deps = [],\n  }: { initialValue?: T | null; deps?: React.DependencyList } = {},\n) {\n  const ref = useRef(initialValue);\n\n  return useMemo(\n    () => ({\n      get current() {\n        return ref.current;\n      },\n      set current(nextValue) {\n        ref.current = nextValue;\n        callback(nextValue);\n      },\n    }),\n    [\n      callback,\n      ref,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      ...deps,\n    ],\n  );\n}\n\ntype SettableRef<T> = React.RefCallback<T> | React.MutableRefObject<T>;\n\ntype ValueOrArray<T> = T | ReadonlyArray<T>;\n\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n  initialValue: T,\n): React.MutableRefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null> | null>,\n  initialValue: T | null,\n): React.RefObject<T>;\nexport function useForwardedRef<T>(\n  forwardedRefOrRefs: ValueOrArray<SettableRef<T | null | undefined> | null>,\n  initialValue?: T | null,\n): React.MutableRefObject<T | null | undefined> {\n  const forwardValueToRefs = useCallback(\n    <T,>(\n      forwardedRefOrRefs: ValueOrArray<SettableRef<T> | null>,\n      nextValue: T,\n    ) => {\n      if (Array.isArray(forwardedRefOrRefs)) {\n        forwardedRefOrRefs.forEach(forwardValueToRefs);\n      } else if (typeof forwardedRefOrRefs === 'function') {\n        forwardedRefOrRefs(nextValue);\n      } else if (forwardedRefOrRefs) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/40527\n        forwardedRefOrRefs.current = nextValue;\n      }\n    },\n    [],\n  );\n\n  return useObservedRef(\n    useCallback(\n      value => forwardValueToRefs(forwardedRefOrRefs, value),\n      [forwardedRefOrRefs, forwardValueToRefs],\n    ),\n    { initialValue },\n  );\n}\n","// Currently using Material UI useId hook until we can upgrade to React 18's useId\n// https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/useId.ts\nimport { useEffect, useState } from 'react';\n\ninterface Params {\n  prefix?: string;\n  id?: string;\n}\n\nlet globalId = 0;\n\nfunction useGlobalId({ id: idOverride, prefix }: Params): string {\n  const [defaultId, setDefaultId] = useState<string | number | undefined>(\n    idOverride,\n  );\n\n  useEffect(() => {\n    if (defaultId == null) {\n      // Fallback to this default id when possible.\n      // Use the incrementing value for client-side rendering only.\n      // We can't use it server-side.\n      // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem\n      globalId += 1;\n      setDefaultId(globalId);\n    }\n  }, [defaultId, prefix]);\n\n  return idOverride ? idOverride : `${prefix ?? 'lg'}-${defaultId}`;\n}\n\nexport default function useId({ prefix, id: idOverride }: Params): string {\n  return useGlobalId({ id: idOverride, prefix });\n}\n","import { useEffect, useLayoutEffect } from 'react';\n\nconst useIsomorphicLayoutEffect: typeof useLayoutEffect = (...args) => {\n  const effectHook =\n    typeof window === 'undefined' ? useEffect : useLayoutEffect;\n  return effectHook(...args);\n};\n\nexport default useIsomorphicLayoutEffect;\n","import { RefObject, useEffect } from 'react';\n\n/**\n * Automatically scrolls the container to\n * ensure the elementRef is always at the top of the container.\n *\n * Required styles:\n * ```css\n * .container-parent {\n *    position: relative | absolute;\n * }\n *\n * .container {\n *    position: relative;\n *    max-height: {number};\n *    overflow: auto;\n * }\n *\n * .element {\n *    position: relative;\n *    height: {number}\n * }\n * ```\n */\nexport const useAutoScroll = (\n  /**\n   * The element to keep at the top\n   */\n  elementRef?: RefObject<HTMLElement>,\n  /**\n   * The container element\n   */\n  containerRef?: RefObject<HTMLElement>,\n  /**\n   * A vertical offset amount to account for padding/margin\n   */\n  offset = 0,\n) => {\n  // When the focused option changes, update the menu scroll if necessary\n  useEffect(() => {\n    if (\n      elementRef &&\n      elementRef.current &&\n      containerRef &&\n      containerRef.current\n    ) {\n      const { offsetTop: elementTop } = elementRef.current;\n      const { scrollTop: containerTop, offsetHeight: containerHeight } =\n        containerRef.current;\n\n      if (elementTop > containerHeight || elementTop < containerTop) {\n        containerRef.current.scrollTo({\n          top: elementTop - offset,\n          behavior: 'smooth', // TODO: update this based on prefers-reduced-motion\n        });\n      }\n    }\n  }, [containerRef, elementRef, offset]);\n};\n","import { consoleOnce } from '@leafygreen-ui/lib';\n\nimport useEventListener from './useEventListener';\n\ninterface UseBackdropClickOptions {\n  /**\n   * Whether the callback is enabled.\n   * It's recommended to set this to `false` when not in use,\n   * and toggle to `true` when the main elements (menu, tooltip, etc) are visible\n   *\n   * @default true\n   */\n  enabled: boolean;\n\n  /**\n   * Allows the event to bubble up to other elements.\n   * When false, this ensures that only the `callback` is fired\n   * when the backdrop is clicked,\n   * (i.e. no other click event handlers are fired),\n   * and that the clicked element does not receive focus.\n   *\n   * To allow the event to propagate, set this to `true`,\n   * and ensure that you are correctly detecting whether the click target should receive focus,\n   * or whether focus should return to the popover trigger.\n   *\n   * @default false\n   */\n  allowPropagation?: boolean;\n}\n\n/**\n * Fires a callback when any element(s)\n * _except_ those passed in as `foreground` is clicked.\n *\n * Note: Disable this hook (with the `enabled` arg)\n * if the `foreground` element(s) are not in view (e.g. menu, tooltip, etc.).\n */\nexport function useBackdropClick(\n  /**\n   * Function called when any element\n   * _other than_ those provided is clicked.\n   *\n   * Callback is fired on the `click` event's capture phase,\n   * (i.e. before a click handler on the target element is fired)\n   */\n  callback: Function,\n\n  /**\n   * The primary element(s) that are excluded from backdrop click\n   */\n  foreground:\n    | React.RefObject<HTMLElement>\n    | Array<React.RefObject<HTMLElement>>,\n\n  /** Additional options for the hook. See {@link UseBackdropClickOptions} */\n  options: boolean | UseBackdropClickOptions = {\n    enabled: true,\n    allowPropagation: false,\n  },\n): void {\n  /**\n   * We add two event handlers to the document to handle the backdrop click behavior.\n   * Intended behavior is to fire the callback (usually closing a menu, tooltip, etc.),\n   * and keep focus on the component.\n   *\n   * No other click event handlers should fire on backdrop click\n   *\n   * 1. Mousedown event fires\n   * 2. We prevent `mousedown`'s default behavior, to prevent focus from being applied to the body (or other target)\n   * 3. Click event fires\n   * 4. We handle this event on _capture_, and stop propagation before the `click` event propagates all the way to any other element.\n   *  This ensures that even if we click on a button, that handler is not fired\n   * 5. Then we call the callback (typically fires `closeMenu`, setting `isOpen = false`, and rerender the component)\n   */\n\n  // TODO: Remove this in a major version\n  // https://jira.mongodb.org/browse/LG-5012\n  // To avoid a breaking change, we allow the `options` argument to be a boolean\n  // If it is a boolean, we assume that it is the `enabled` option\n  const { enabled, allowPropagation } =\n    typeof options === 'boolean'\n      ? { enabled: options, allowPropagation: false }\n      : options;\n\n  if (typeof options === 'boolean') {\n    consoleOnce.warn(\n      \"useBackdropClick: The 'enabled' boolean argument is deprecated. Please use the 'options' object argument instead.\",\n    );\n  }\n\n  useEventListener(\n    'mousedown',\n    mousedown => {\n      if (!doesComponentContainEventTarget(mousedown)) {\n        if (!allowPropagation) {\n          mousedown.preventDefault(); // Prevent focus from being applied to body\n          mousedown.stopPropagation(); // Stop any other mousedown events from firing\n        }\n      }\n    },\n    {\n      enabled,\n    },\n  );\n\n  useEventListener(\n    'click',\n    click => {\n      if (!doesComponentContainEventTarget(click)) {\n        if (!allowPropagation) {\n          click.stopPropagation(); // Stop any other click events from firing\n        }\n        callback(click);\n      }\n    },\n    {\n      options: { capture: true },\n      enabled,\n    },\n  );\n\n  /**\n   * Returns whether the event target within the component\n   */\n  function doesComponentContainEventTarget({ target }: MouseEvent): boolean {\n    return Array.isArray(foreground)\n      ? foreground.some(ref => ref.current?.contains(target as Node))\n      : foreground.current?.contains(target as Node) || false;\n  }\n}\n","import { ChangeEventHandler, MutableRefObject } from 'react';\n\nimport { createSyntheticEvent } from '@leafygreen-ui/lib';\n\nimport { useControlled } from '../useControlled';\n\nimport { ControlledValueReturnObject } from './useControlledValue.types';\n\n/**\n * A hook that enables an input component to be both controlled or uncontrolled.\n *\n * Returns a {@link ControlledValueReturnObject} with the controlled or uncontrolled `value`,\n * `onChange` & `onClear` handlers, a `setInternalValue` setter, and a boolean `isControlled`\n */\nexport const useControlledValue = <T>(\n  controlledValue?: T,\n  changeHandler?: ChangeEventHandler<any> | null,\n  initialValue?: T,\n): ControlledValueReturnObject<T> => {\n  // Use the new useControlled hook under the hood\n  const { isControlled, value, setUncontrolledValue } = useControlled(\n    controlledValue,\n    undefined, // We'll handle onChange differently for input-specific logic\n    initialValue,\n  );\n\n  // Create a change event handler that either updates the internal state\n  // or fires an external change handler\n  const handleChange: ChangeEventHandler<any> = e => {\n    changeHandler?.(e);\n    if (!isControlled) {\n      setUncontrolledValue(e.target.value as T);\n    }\n  };\n\n  // A wrapper around `handleChange` that fires a simulated event\n  const updateValue = (newVal: T | undefined, ref: MutableRefObject<any>) => {\n    if (ref.current) {\n      ref.current.value = newVal;\n      const synthEvt = createSyntheticEvent(\n        new Event('change', {\n          cancelable: true,\n          bubbles: true,\n        }),\n        ref.current,\n      );\n\n      handleChange(synthEvt);\n    }\n  };\n\n  return {\n    isControlled,\n    value,\n    handleChange,\n    setUncontrolledValue,\n    updateValue,\n  };\n};\n","/**\n * Based on https://github.com/fitzmode/use-dynamic-refs/blob/master/src/index.tsx\n */\n\nimport * as React from 'react';\n\nimport { consoleOnce } from '@leafygreen-ui/lib';\n\nexport interface UseDynamicRefsArgs {\n  prefix?: string;\n}\n\n/** The Map type for a given ref object  */\nexport type RefMap<T> = Map<string, React.RefObject<T>>;\n\n/**\n * @internal\n */\nexport function getGetRef<T>(refMap: RefMap<T>) {\n  /**\n   * Returns a ref (or creates a new one) for the provided key\n   */\n  function getRef(): undefined;\n  function getRef(key: string): React.RefObject<T>;\n  function getRef(key?: string): React.RefObject<T> | undefined {\n    if (!key) {\n      consoleOnce.error('`useDynamicRefs`: Cannot get ref without key');\n      return;\n    }\n\n    if (refMap.get(key)) {\n      return refMap.get(key) as React.RefObject<T>;\n    }\n\n    const ref = React.createRef<T>();\n    refMap.set(key, ref);\n    return ref;\n  }\n\n  return getRef;\n}\n\n/** The function signature for the function returned by `useDynamicRefs` */\nexport type DynamicRefGetter<T> = ReturnType<typeof getGetRef<T>>;\n\n/**\n * Returns a ref \"getter\" function for the specified namespace (prefix).\n *\n * Calling the ref \"getter\" with a key will return a ref for the given namespace and key\n */\nexport function useDynamicRefs<T>(\n  args?: UseDynamicRefsArgs,\n): DynamicRefGetter<T> {\n  const prefix = args?.prefix;\n\n  const getRef = React.useMemo(\n    () => {\n      const refMap: RefMap<T> = new Map<string, React.RefObject<T>>();\n      const getter = getGetRef<T>(refMap);\n      return getter;\n    },\n    // FIXME:\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    prefix ? [prefix] : [],\n  );\n\n  return getRef;\n}\n","import { useEffect, useRef } from 'react';\n\n/**\n * Returns whether this is the first render of a component.\n *\n * Additionally, calls the provided callback function _only_ on first render\n */\nexport const useFirstRender = (effect?: () => void): boolean => {\n  const isFirstRender = useRef(true);\n\n  useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      effect?.();\n    }\n  }, [effect]);\n\n  return isFirstRender.current;\n};\n","import { useCallback, useState } from 'react';\n\n/**\n * Hook that forces a re-render.\n */\nexport function useForceRerender(): () => void {\n  const [, updateState] = useState<Object>({});\n  const forceRerender = useCallback(() => updateState({}), []);\n\n  return forceRerender;\n}\n","import * as React from 'react';\n\n/**\n * Merges an array of refs into a single memoized callback ref or `null`.\n */\nexport function useMergeRefs<Instance>(\n  refs: Array<React.Ref<Instance> | undefined>,\n): React.RefCallback<Instance> | null {\n  return React.useMemo(() => {\n    if (refs.every(ref => ref == null)) {\n      return null;\n    }\n\n    return value => {\n      refs.forEach(ref => {\n        if (typeof ref === 'function') {\n          ref(value);\n        } else if (ref != null) {\n          (ref as React.MutableRefObject<Instance | null>).current = value;\n        }\n      });\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, refs);\n}\n","import { breakpoints } from '@leafygreen-ui/tokens';\n\nimport useViewportSize from '../useViewportSize';\n\n/**\n * Returns whether the viewport is mobile-sized\n */\nexport const useMobile = () => {\n  const viewport = useViewportSize();\n\n  const isMobileSize = viewport?.width\n    ? viewport.width <= breakpoints.Tablet\n    : false;\n\n  return {\n    isMobileSize,\n  };\n};\n","import { useEffect, useState } from 'react';\n\ntype MutationHandler<Value> = (\n  mutations: Array<MutationRecord>,\n  observer: MutationObserver,\n) => Value;\n\n/**\n * Hook to subscribe to changes on the DOM.\n * @param target HTML element that is subscribed to DOM changes.\n * @param options Object with information about what DOM changes to subscribe to.\n * @param callback Callback function to execute inside of MutationObserver instance.\n * @param enabled Determines whether or not the hook should run, defaults to true.\n */\nexport default function useMutationObserver<Value>(\n  target: HTMLElement | null,\n  options: MutationObserverInit,\n  callback: MutationHandler<Value>,\n  enabled = true,\n): Value | undefined {\n  const [value, setValue] = useState<Value>();\n\n  useEffect(() => {\n    if (!enabled) {\n      return;\n    }\n\n    const observer = new MutationObserver((...args) => {\n      setValue(callback(...args));\n    });\n\n    if (target) {\n      observer.observe(target, options);\n    }\n\n    return () => observer.disconnect();\n  }, [target, options, callback, enabled]);\n\n  return value;\n}\n","import { useRef } from 'react';\nimport isEqual from 'lodash/isEqual';\n\nexport default function useObjectDependency<T>(object: T): T {\n  const ref = useRef<T>();\n\n  // we need isEqual for deep object comparison\n  if (ref.current === undefined || !isEqual(ref.current, object)) {\n    ref.current = object;\n  }\n\n  return ref.current;\n}\n","import { useEffect, useRef, useState } from 'react';\n\nimport useEventListener from './useEventListener';\n\nfunction useVisibilityChange() {\n  const isVisibilityStateVisible = () => document.visibilityState === 'visible';\n\n  const [isVisible, setIsVisible] = useState(true);\n\n  useEffect(() => {\n    setIsVisible(isVisibilityStateVisible);\n  }, []);\n\n  useEventListener('visibilitychange', () => {\n    setIsVisible(isVisibilityStateVisible);\n  });\n\n  return isVisible;\n}\n\ntype OnPoll = () => void;\n\ninterface PollerOptions {\n  /**\n   * How frequently should we call the onPoll handler. Defaults to 30 seconds.\n   * @default 30000\n   */\n  interval?: number;\n\n  /**\n   * Should we immediately trigger the onPoll handler.\n   * @default true\n   */\n  immediate?: boolean;\n\n  /**\n   * Should we be polling.\n   * @default true\n   */\n  enabled?: boolean;\n}\n\nexport default function usePoller(\n  onPoll: OnPoll,\n  { interval = 30e3, immediate = true, enabled = true }: PollerOptions = {},\n) {\n  const savedCallback = useRef<OnPoll>();\n  const isVisible = useVisibilityChange();\n\n  const isPolling = isVisible && enabled;\n\n  useEffect(() => {\n    savedCallback.current = onPoll;\n  });\n\n  useEffect(() => {\n    if (!isPolling) {\n      return;\n    }\n\n    // Using this reflection to get return type of setTimeout so we don't have to\n    // use window.setTimeout, makes this more cross-environment compatible\n    // Sourced from: https://stackoverflow.com/a/51040768\n    let id: ReturnType<typeof setTimeout>;\n\n    function scheduleNextPoll() {\n      unscheduleNextPoll();\n      id = setTimeout(poll, interval);\n    }\n\n    function unscheduleNextPoll() {\n      clearTimeout(id);\n    }\n\n    function poll() {\n      Promise.resolve(savedCallback.current?.()).finally(scheduleNextPoll);\n    }\n\n    if (immediate) {\n      poll();\n    } else {\n      scheduleNextPoll();\n    }\n\n    return unscheduleNextPoll;\n  }, [interval, immediate, isPolling]);\n}\n","import { useEffect, useRef } from 'react';\n\n/**\n * Hook to store previous props\n * https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state\n */\nexport default function usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n}\n","import { useCallback, useRef, useState } from 'react';\n\n/**\n *\n * A combination of useState and useRef,\n * returns the current state, a `setState` and a `getState` function.\n *\n * Use the `getState` function inside an event listener callbacks\n * in order to avoid referencing a stale state\n *\n * @param initial\n * @returns [state, setState, getState]\n */\nexport function useStateRef<T extends any>(\n  initial: T,\n): [T, (x: T) => void, () => T] {\n  const [state, _setState] = useState<T>(initial);\n  const ref = useRef<T>(state);\n\n  const setState = useCallback(\n    (newVal: T): void => {\n      _setState(newVal);\n      ref.current = newVal;\n    },\n    [_setState],\n  );\n\n  const getState = useCallback((): T => {\n    return ref.current;\n  }, []);\n\n  return [state, setState, getState];\n}\n","import { useState } from 'react';\nimport isUndefined from 'lodash/isUndefined';\n\nexport default function useValidation<\n  T extends HTMLInputElement | HTMLTextAreaElement,\n>(handleValidation?: (value: string) => void) {\n  const [isDirty, setIsDirty] = useState(false);\n\n  if (isUndefined(handleValidation) || typeof handleValidation !== 'function') {\n    return {\n      onBlur: () => {},\n      onChange: () => {},\n    };\n  }\n\n  const onBlur = (e: React.FocusEvent<T>) => {\n    setIsDirty(true);\n    handleValidation?.(e.target.value);\n  };\n\n  const onChange = (e: React.ChangeEvent<T>) => {\n    if (isDirty) {\n      handleValidation?.(e.target.value);\n    }\n  };\n\n  return {\n    onBlur,\n    onChange,\n  };\n}\n"],"names":["useSsrCheck","_useState2","_slicedToArray","useState","window","isSsr","setIsSsr","useEffect","getViewportSize","width","innerWidth","height","innerHeight","useViewportSize","viewportSize","setViewportUpdateVal","calcResize","debounce","addEventListener","removeEventListener","useAvailableSpace$1","triggerRef","margin","arguments","length","undefined","current","_triggerRef$current$g","getBoundingClientRect","triggerTop","top","triggerBottom","bottom","Math","max","useEventListener","type","eventCallback","_ref","options","_ref$enabled","enabled","_ref$dependencies","dependencies","element","memoizedEventCallback","useRef","callback","e","eventListenerOptions","_objectSpread","once","document","console","error","concat","_typeof","useControlled","controlledValue","onChange","initialValue","isControlled","useMemo","isUndefined","uncontrolledValue","setUncontrolledValue","value","default","consoleOnce","updateValue","newVal","useEscapeKey$1","keyCode","stopImmediatePropagation","handleEscape","useObservedRef","_ref$deps","deps","ref","nextValue","_toConsumableArray","globalId","useIsomorphicLayoutEffect$1","useLayoutEffect","apply","elementRef","containerRef","offset","elementTop","offsetTop","_containerRef$current","containerTop","scrollTop","offsetHeight","scrollTo","behavior","foreground","allowPropagation","doesComponentContainEventTarget","_ref2","_foreground$current","target","Array","isArray","some","_ref$current","contains","warn","mousedown","preventDefault","stopPropagation","click","capture","changeHandler","_useControlled","handleChange","synthEvt","createSyntheticEvent","Event","cancelable","bubbles","args","prefix","React","getter","refMap","key","get","createRef","set","getGetRef","Map","effect","isFirstRender","updateState","useCallback","forwardedRefOrRefs","forwardValueToRefs","forEach","idOverride","id","defaultId","setDefaultId","useGlobalId","refs","every","viewport","isMobileSize","breakpoints","Tablet","setValue","observer","MutationObserver","observe","disconnect","object","isEqual","onPoll","_ref$interval","interval","_ref$immediate","immediate","savedCallback","isPolling","isVisibilityStateVisible","visibilityState","isVisible","setIsVisible","useVisibilityChange","poll","scheduleNextPoll","unscheduleNextPoll","setTimeout","clearTimeout","_savedCallback$curren","Promise","resolve","call","finally","initial","state","_setState","handleValidation","isDirty","setIsDirty","onBlur"],"mappings":"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"}