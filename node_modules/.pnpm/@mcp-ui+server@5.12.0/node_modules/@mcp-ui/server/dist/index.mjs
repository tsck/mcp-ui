const o = "mcpui.dev/ui-", d = `"use strict";
(() => {
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // src/adapters/appssdk/adapter-runtime.ts
  var MCPUIAppsSdkAdapter = class {
    constructor(config = {}) {
      __publicField(this, "config");
      __publicField(this, "pendingRequests", /* @__PURE__ */ new Map());
      __publicField(this, "messageIdCounter", 0);
      __publicField(this, "originalPostMessage", null);
      this.config = {
        logger: config.logger || console,
        hostOrigin: config.hostOrigin || window.location.origin,
        timeout: config.timeout || 3e4,
        intentHandling: config.intentHandling || "prompt"
      };
    }
    /**
     * Initialize the adapter and monkey-patch postMessage if Apps SDK is present
     */
    install() {
      if (!window.openai) {
        this.config.logger.warn("[MCPUI-Apps SDK Adapter] window.openai not detected. Adapter will not activate.");
        return false;
      }
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Initializing adapter...");
      this.patchPostMessage();
      this.setupAppsSdkEventListeners();
      this.sendRenderData();
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter initialized successfully");
      return true;
    }
    /**
     * Clean up pending requests and restore original postMessage
     */
    uninstall() {
      for (const request of this.pendingRequests.values()) {
        clearTimeout(request.timeoutId);
        request.reject(new Error("Adapter uninstalled"));
      }
      this.pendingRequests.clear();
      if (this.originalPostMessage) {
        try {
          const parentWindow = window.parent ?? null;
          if (parentWindow) {
            parentWindow.postMessage = this.originalPostMessage;
          }
          this.config.logger.log("[MCPUI-Apps SDK Adapter] Restored original parent.postMessage");
        } catch (error) {
          this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to restore original postMessage:", error);
        }
      }
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Adapter uninstalled");
    }
    /**
     * Monkey-patch parent.postMessage to intercept MCP-UI messages
     * and forward non-MCP-UI messages to the original postMessage
     */
    patchPostMessage() {
      const parentWindow = window.parent ?? null;
      this.originalPostMessage = parentWindow?.postMessage?.bind(parentWindow) ?? null;
      if (!this.originalPostMessage) {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] parent.postMessage does not exist, installing shim only");
      } else {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Monkey-patching parent.postMessage to intercept MCP-UI messages");
      }
      const postMessageInterceptor = (message, targetOriginOrOptions, transfer) => {
        if (this.isMCPUIMessage(message)) {
          const mcpMessage = message;
          this.config.logger.debug("[MCPUI-Apps SDK Adapter] Intercepted MCP-UI message:", mcpMessage.type);
          this.handleMCPUIMessage(mcpMessage);
        } else {
          if (this.originalPostMessage) {
            this.config.logger.debug("[MCPUI-Apps SDK Adapter] Forwarding non-MCP-UI message to original postMessage");
            if (typeof targetOriginOrOptions === "string" || targetOriginOrOptions === void 0) {
              const targetOrigin = targetOriginOrOptions ?? "*";
              this.originalPostMessage(message, targetOrigin, transfer);
            } else {
              this.originalPostMessage(message, targetOriginOrOptions);
            }
          } else {
            this.config.logger.warn("[MCPUI-Apps SDK Adapter] No original postMessage to forward to, ignoring message:", message);
          }
        }
      };
      try {
        if (parentWindow) {
          parentWindow.postMessage = postMessageInterceptor;
        }
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Failed to monkey-patch parent.postMessage:", error);
      }
    }
    /**
     * Check if a message is an MCP-UI protocol message
     */
    isMCPUIMessage(message) {
      if (!message || typeof message !== "object") {
        return false;
      }
      const msg = message;
      return typeof msg.type === "string" && (msg.type.startsWith("ui-") || ["tool", "prompt", "intent", "notify", "link"].includes(msg.type));
    }
    /**
     * Handle incoming MCP-UI messages and translate to Apps SDK actions
     */
    async handleMCPUIMessage(message) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Received MCPUI message:", message.type);
      try {
        switch (message.type) {
          case "tool":
            await this.handleToolMessage(message);
            break;
          case "prompt":
            await this.handlePromptMessage(message);
            break;
          case "intent":
            await this.handleIntentMessage(message);
            break;
          case "notify":
            await this.handleNotifyMessage(message);
            break;
          case "link":
            await this.handleLinkMessage(message);
            break;
          case "ui-lifecycle-iframe-ready":
            this.sendRenderData();
            break;
          case "ui-request-render-data":
            this.sendRenderData(message.messageId);
            break;
          case "ui-size-change":
            this.handleSizeChange(message);
            break;
          case "ui-request-data":
            this.handleRequestData(message);
            break;
          default:
            this.config.logger.warn("[MCPUI-Apps SDK Adapter] Unknown message type:", message.type);
        }
      } catch (error) {
        this.config.logger.error("[MCPUI-Apps SDK Adapter] Error handling message:", error);
        if (message.messageId) {
          this.sendErrorResponse(message.messageId, error);
        }
      }
    }
    /**
     * Handle 'tool' message - call Apps SDK tool
     */
    async handleToolMessage(message) {
      if (message.type !== "tool")
        return;
      const { toolName, params } = message.payload;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      try {
        if (!window.openai?.callTool) {
          throw new Error("Tool calling is not supported in this environment");
        }
        const result = await this.withTimeout(
          window.openai.callTool(toolName, params),
          messageId
        );
        this.sendSuccessResponse(messageId, result);
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'prompt' message - send followup turn
     */
    async handlePromptMessage(message) {
      if (message.type !== "prompt")
        return;
      const prompt = message.payload.prompt;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      try {
        if (!window.openai?.sendFollowUpMessage) {
          throw new Error("Followup turns are not supported in this environment");
        }
        await this.withTimeout(
          window.openai.sendFollowUpMessage({ prompt }),
          messageId
        );
        this.sendSuccessResponse(messageId, { success: true });
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'intent' message - convert to prompt or ignore based on config
     */
    async handleIntentMessage(message) {
      if (message.type !== "intent")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      if (this.config.intentHandling === "ignore") {
        this.config.logger.log("[MCPUI-Apps SDK Adapter] Intent ignored:", message.payload.intent);
        this.sendSuccessResponse(messageId, { ignored: true });
        return;
      }
      const { intent, params } = message.payload;
      const prompt = \`\${intent}\${params ? \`: \${JSON.stringify(params)}\` : ""}\`;
      try {
        if (!window.openai?.sendFollowUpMessage) {
          throw new Error("Followup turns are not supported in this environment");
        }
        await this.withTimeout(
          window.openai.sendFollowUpMessage({ prompt }),
          messageId
        );
        this.sendSuccessResponse(messageId, { success: true });
      } catch (error) {
        this.sendErrorResponse(messageId, error);
      }
    }
    /**
     * Handle 'notify' message - log only
     */
    async handleNotifyMessage(message) {
      if (message.type !== "notify")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.config.logger.log("[MCPUI-Apps SDK Adapter] Notification:", message.payload.message);
      this.sendAcknowledgment(messageId);
      this.sendSuccessResponse(messageId, { acknowledged: true });
    }
    /**
     * Handle 'link' message - not supported in Apps SDK environments
     */
    async handleLinkMessage(message) {
      if (message.type !== "link")
        return;
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      this.sendErrorResponse(messageId, new Error("Navigation is not supported in Apps SDK environment"));
    }
    /**
     * Handle size change - no-op in Apps SDK environment
     */
    handleSizeChange(message) {
      this.config.logger.debug("[MCPUI-Apps SDK Adapter] Size change requested (no-op in Apps SDK):", message.payload);
    }
    /**
     * Handle generic data request
     */
    handleRequestData(message) {
      const messageId = message.messageId || this.generateMessageId();
      this.sendAcknowledgment(messageId);
      this.sendErrorResponse(messageId, new Error("Generic data requests not yet implemented"));
    }
    /**
     * Setup listeners for Apps SDK events
     */
    setupAppsSdkEventListeners() {
      window.addEventListener("openai:set_globals", () => {
        this.config.logger.debug("[MCPUI-Apps SDK Adapter] Globals updated");
        this.sendRenderData();
      });
    }
    /**
     * Gather render data from Apps SDK and send to widget
     */
    sendRenderData(requestMessageId) {
      if (!window.openai)
        return;
      const renderData = {
        toolInput: window.openai.toolInput,
        toolOutput: window.openai.toolOutput,
        widgetState: window.openai.widgetState,
        locale: window.openai.locale || "en-US",
        theme: window.openai.theme || "light",
        displayMode: window.openai.displayMode || "inline",
        maxHeight: window.openai.maxHeight
      };
      this.dispatchMessageToIframe({
        type: "ui-lifecycle-iframe-render-data",
        messageId: requestMessageId,
        payload: { renderData }
      });
    }
    /**
     * Send acknowledgment for a message
     */
    sendAcknowledgment(messageId) {
      this.dispatchMessageToIframe({
        type: "ui-message-received",
        payload: { messageId }
      });
    }
    /**
     * Send success response
     */
    sendSuccessResponse(messageId, response) {
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        payload: { messageId, response }
      });
    }
    /**
     * Send error response
     */
    sendErrorResponse(messageId, error) {
      const errorObj = error instanceof Error ? { message: error.message, name: error.name } : { message: String(error) };
      this.dispatchMessageToIframe({
        type: "ui-message-response",
        payload: { messageId, error: errorObj }
      });
    }
    /**
     * Dispatch a MessageEvent to the iframe (widget)
     * Simulates messages that would normally come from the parent/host
     */
    dispatchMessageToIframe(data) {
      const event = new MessageEvent("message", {
        data,
        origin: this.config.hostOrigin,
        source: null
      });
      window.dispatchEvent(event);
    }
    /**
     * Wrap a promise with timeout
     */
    async withTimeout(promise, requestId) {
      return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
          this.pendingRequests.delete(requestId);
          reject(new Error(\`Request timed out after \${this.config.timeout}ms\`));
        }, this.config.timeout);
        this.pendingRequests.set(requestId, {
          messageId: requestId,
          type: "generic",
          resolve,
          reject,
          timeoutId
        });
        promise.then((result) => {
          clearTimeout(timeoutId);
          this.pendingRequests.delete(requestId);
          resolve(result);
        }).catch((error) => {
          clearTimeout(timeoutId);
          this.pendingRequests.delete(requestId);
          reject(error);
        });
      });
    }
    /**
     * Generate a unique message ID
     */
    generateMessageId() {
      return \`adapter-\${Date.now()}-\${++this.messageIdCounter}\`;
    }
  };
  var adapterInstance = null;
  function initAdapter(config) {
    if (adapterInstance) {
      console.warn("[MCPUI-Apps SDK Adapter] Adapter already initialized");
      return true;
    }
    adapterInstance = new MCPUIAppsSdkAdapter(config);
    return adapterInstance.install();
  }
  function uninstallAdapter() {
    if (adapterInstance) {
      adapterInstance.uninstall();
      adapterInstance = null;
    }
  }
  if (typeof window !== "undefined") {
    const adapterWindow = window;
    if (!adapterWindow.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL) {
      initAdapter();
    }
  }
})();
`;
function g(e) {
  const n = e ? JSON.stringify(e) : "{}";
  return `
<script>
(function() {
  'use strict';
  
  ${d}
  
  // Override auto-init from runtime and initialize with provided config
  if (typeof window !== 'undefined') {
    window.MCP_APPSSDK_ADAPTER_NO_AUTO_INSTALL = true; // Prevent auto-init from bundled code
    
    // Initialize with config from server
    if (typeof initAdapter === 'function') {
      initAdapter(${n});
    }
    
    // Expose functions globally
    if (typeof window.MCPUIAppsSdkAdapter === 'undefined') {
      window.MCPUIAppsSdkAdapter = {
        init: initAdapter,
        uninstall: uninstallAdapter,
      };
    }
  }
})();
<\/script>
`.trim();
}
function i(e) {
  const n = { ...e.resourceProps ?? {} };
  if (e.uiMetadata || e.metadata) {
    const s = Object.fromEntries(
      Object.entries(e.uiMetadata ?? {}).map(([a, t]) => [
        `${o}${a}`,
        t
      ])
    );
    n._meta = {
      ...s,
      ...e.metadata ?? {},
      ...n._meta ?? {}
    };
  }
  return n;
}
function p(e) {
  if (typeof Buffer < "u")
    return Buffer.from(e, "utf-8").toString("base64");
  if (typeof TextEncoder < "u" && typeof btoa < "u") {
    const s = new TextEncoder().encode(e);
    let a = "";
    const t = 8192;
    for (let r = 0; r < s.length; r += t)
      a += String.fromCharCode(...s.slice(r, r + t));
    return btoa(a);
  } else {
    console.warn(
      "MCP-UI SDK: Buffer API and TextEncoder/btoa not available. Base64 encoding might not be UTF-8 safe."
    );
    try {
      return btoa(e);
    } catch {
      throw new Error(
        "MCP-UI SDK: Suitable UTF-8 to Base64 encoding method not found, and fallback btoa failed."
      );
    }
  }
}
function l(e) {
  if (e && e.appsSdk?.enabled)
    return e.appsSdk.mimeType ?? "text/html+skybridge";
}
function c(e, n) {
  if (!n)
    return e;
  const s = [];
  if (n.appsSdk?.enabled) {
    const r = g(n.appsSdk.config);
    s.push(r);
  }
  if (s.length === 0)
    return e;
  const a = s.join(`
`);
  let t;
  return e.includes("<head>") ? t = e.replace("<head>", `<head>
${a}`) : e.includes("<html>") ? t = e.replace("<html>", `<html>
<head>
${a}
</head>`) : t = `${a}
${e}`, t;
}
function m(e) {
  let n, s;
  if (e.content.type === "rawHtml") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'rawHtml'.");
    if (n = e.content.htmlString, typeof n != "string")
      throw new Error(
        "MCP-UI SDK: content.htmlString must be provided as a string when content.type is 'rawHtml'."
      );
    e.adapters ? (n = c(n, e.adapters), s = l(e.adapters) ?? "text/html") : s = "text/html";
  } else if (e.content.type === "externalUrl") {
    if (!e.uri.startsWith("ui://"))
      throw new Error(
        "MCP-UI SDK: URI must start with 'ui://' when content.type is 'externalUrl'."
      );
    if (n = e.content.iframeUrl, typeof n != "string")
      throw new Error(
        "MCP-UI SDK: content.iframeUrl must be provided as a string when content.type is 'externalUrl'."
      );
    s = "text/uri-list";
  } else if (e.content.type === "remoteDom") {
    if (!e.uri.startsWith("ui://"))
      throw new Error("MCP-UI SDK: URI must start with 'ui://' when content.type is 'remoteDom'.");
    if (n = e.content.script, typeof n != "string")
      throw new Error(
        "MCP-UI SDK: content.script must be provided as a string when content.type is 'remoteDom'."
      );
    s = `application/vnd.mcp-ui.remote-dom+javascript; framework=${e.content.framework}`;
  } else {
    const t = e.content;
    throw new Error(`MCP-UI SDK: Invalid content.type specified: ${t}`);
  }
  let a;
  switch (e.encoding) {
    case "text":
      a = {
        uri: e.uri,
        mimeType: s,
        text: n,
        ...i(e)
      };
      break;
    case "blob":
      a = {
        uri: e.uri,
        mimeType: s,
        blob: p(n),
        ...i(e)
      };
      break;
    default: {
      const t = e.encoding;
      throw new Error(`MCP-UI SDK: Invalid encoding type: ${t}`);
    }
  }
  return {
    type: "resource",
    resource: a,
    ...e.embeddedResourceProps ?? {}
  };
}
function u(e) {
  window.parent && window.parent.postMessage(e, "*");
}
const h = {
  UI_MESSAGE_RECEIVED: "ui-message-received",
  UI_MESSAGE_RESPONSE: "ui-message-response",
  UI_SIZE_CHANGE: "ui-size-change",
  UI_LIFECYCLE_IFRAME_READY: "ui-lifecycle-iframe-ready",
  UI_LIFECYCLE_IFRAME_RENDER_DATA: "ui-lifecycle-iframe-render-data"
}, f = {
  WAIT_FOR_RENDER_DATA: "waitForRenderData"
};
function w(e, n) {
  return {
    type: "tool",
    payload: {
      toolName: e,
      params: n
    }
  };
}
function I(e) {
  return {
    type: "prompt",
    payload: {
      prompt: e
    }
  };
}
function M(e) {
  return {
    type: "link",
    payload: {
      url: e
    }
  };
}
function y(e, n) {
  return {
    type: "intent",
    payload: {
      intent: e,
      params: n
    }
  };
}
function A(e) {
  return {
    type: "notify",
    payload: {
      message: e
    }
  };
}
export {
  h as InternalMessageType,
  f as ReservedUrlParams,
  m as createUIResource,
  l as getAdapterMimeType,
  g as getAppsSdkAdapterScript,
  u as postUIActionResult,
  y as uiActionResultIntent,
  M as uiActionResultLink,
  A as uiActionResultNotification,
  I as uiActionResultPrompt,
  w as uiActionResultToolCall,
  c as wrapHtmlWithAdapters
};
//# sourceMappingURL=index.mjs.map
